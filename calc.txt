/**
    The Calculator Class tokenizes the expression, then converts it to postfix,
    and finally evaluates the postfix. 
*/
class Calculator {
    String expression;

    /**
        @param input
        Contructs the calculator for the given expression.
        Checks if the expression is valid.
    */
    public Calculator(String input) {
        expression = input.replaceAll(" ", "");
        if (!isValidExpression()) {
            System.out.println("Error: Improper expression format.");
            System.exit(1);
        }
    
        System.out.println(expression);
    }

    /**
        Checks validity of expression.
        @return true if valid, false otherwise.
    */
    private boolean isValidExpression() {
        if (!hasMatchingParentheses()) {
            System.out.println("Error: Unmatched parentheses.");
            return false;
        }
        
        return true;
    }

    /**
        Checks use of parenthesis.
        @return true if parenthesis are used appropriately, false otherwise
    */
    private boolean hasMatchingParentheses() {
        Stack<Character> parenthesesStack = new Stack<>();
    
        for (char c : expression.toCharArray()) {
            if (c == '(') {
                parenthesesStack.push(c);
            }

            else if (c == ')') {
                try {
                    parenthesesStack.pop();
                }
                catch (EmptyStackException e) {
                    return false;
                }
            }
        }
        
        return parenthesesStack.isEmpty();
    }

    /**
        Evaluates the expression.
        @return result of the evaluation
    */
    public int evaluate() {
        String postfixExpression = convertToPostFix();
        return evaluatePostFix(postfixExpression);
    }

    /**
        Converts the expression input to viable postfix string
        @return postfix expression
    */
    public String convertToPostFix() {
        Stack<String> operators = new Stack<>();
        Stack<String> numbers = new Stack<>();
        
        StringBuilder currentNumber = new StringBuilder();
        
        for (char c : expression.toCharArray()) {
            if (Character.isDigit(c)) {
                //If the character is a digit, append it
                currentNumber.append(c);
            }
            else {
                if (currentNumber.length() > 0) {
                    //If there's a 1 digit number
                    numbers.push(currentNumber.toString());
                    currentNumber.setLength(0); //Reset
                }
    
                switch (c) {
                    case '+', '-', '*', '/', '^' -> {
                        while (!operators.isEmpty() && hasPrecedence(operators.peek(), Character.toString(c))) {
                            numbers.push(operators.pop());
                        }
                        operators.push(Character.toString(c));
                    }
                    case '(' -> operators.push("(");
                    case ')' -> {
                        while (!operators.isEmpty() && !operators.peek().equals("(")) {
                            numbers.push(operators.pop());
                        }
                        operators.pop();
                    }
                }
            }
        }
    
        if (currentNumber.length() > 0) {
            //If number is greater than 9
            numbers.push(currentNumber.toString());
        }
        
        while (!operators.isEmpty()) {
            numbers.push(operators.pop());
        }
        
        StringBuilder result = new StringBuilder();
        while (!numbers.isEmpty()) {
            result.insert(0, " " + numbers.pop());
        }
        
        return result.toString().trim();
    }    
    
    /**
        Helper method to check operator precedence
        @param op1
        @param op2
        @return true if op1 higher or equal precendence than op2, false if lower
    */
    private boolean hasPrecedence(String op1, String op2) {
        int precedenceOp1 = getOperatorPrecedence(op1);
        int precedenceOp2 = getOperatorPrecedence(op2);
        return precedenceOp1 >= precedenceOp2;
    }
    
    /**
        Helper method to get operator precedence
        @return precedence number
    */
    private int getOperatorPrecedence(String operator) {
        return switch (operator) {
            case "+", "-" -> 1;
            case "*", "/" -> 2;
            case "^" -> 3;
            default -> 0;
        };
    }    

    /**
        Solves the math expression using the postfix expression.
        @param expression
        @return evaluated postfix expression
    */
    public static int evaluatePostFix(String postfix) {
        Stack<Integer> stack = new Stack<>();

        String[] tokens = tokenizeString(postfix);

        for (String token : tokens) {
            if (token.matches("\\d+")) { //if number
                stack.push(Integer.valueOf(token));
            }
            else if (token.matches("[+\\-*/^]")) {
                int operand2 = stack.pop();
                int operand1 = stack.pop();
                int result = applyOperator(token, operand1, operand2);
                stack.push(result);
            } else {
                throw new IllegalArgumentException("Invalid token: " + token);
            }
        }

        return stack.pop();
    }

    /**
        Tokenizes the string.
        @return tokens
    */
    private static String[] tokenizeString(String expression) {
        return expression.split("\\s+");
    }

    /**
        Helper method that performs the operation.
        @param operator
        @param operand1
        @param operand2
        @return
    */
    private static int applyOperator(String operator, int operand1, int operand2) {
        return switch (operator) {
            case "+" -> operand1 + operand2;
            case "-" -> operand1 - operand2;
            case "*" -> operand1 * operand2;
            case "/" -> operand1 / operand2;
            case "^" -> (int) Math.pow(operand1, operand2);
            default -> throw new IllegalArgumentException("Unsupported operator: " + operator);
        };
    }
}